#!/bin/sh

basename="${0##*/}"
song_playing_file=~/.song-playing
paused=false

cmds_fifo=/tmp/"$basename"-commands.fifo
player_info_fifo=/tmp/"$basename"-info.fifo
rm -f "$cmds_fifo" "$player_info_fifo"
mkfifo "$cmds_fifo" "$player_info_fifo"

default_player=mpg123
: "${player="$default_player"}"

default_loop=all
: "${loop="$default_loop"}"

cleanup_on_exit() {
  terminate_player
  rm -f "$cmds_fifo" "$player_info_fifo"
  kill 0
}

trap cleanup_on_exit EXIT

terminate_player() {
  if [ -n "$player_pid" ]; then
    pkill -P "$player_pid"
  fi
  rm -f "$song_playing_file"
}

cmd_loop() {
  case "$loop" in
    all) loop=one ;;
    one) loop=none ;;
    none) loop=all ;;
  esac
  printf 'loop mode: %s\n' "$loop"
}

cmd_next() {
  terminate_player
}

cmd_pause() {
  if "$paused"; then
    kill -CONT "$player_pid"
    pkill -CONT -P "$player_pid"
    paused=false
  else
    pkill -TSTP -P "$player_pid"
    kill -TSTP "$player_pid"
    paused=true
  fi
}

cmd_previous() {
  terminate_player
  play_song "${previous_song:-"$current_song"}"
}

cmd_quit() {
  exit 0
}

read_commands() {
  while true; do
    while read command; do
      case "$command" in
        player_end)
          return 0
          ;;
        cast_player_info_end)
          # only reachable when the caster notifies its own death, in that case
          # the pid doesn't hold a meaning anymore, clear it to prevent trying
          # to kill it on the next invocation.
          unset cast_player_info_pid
          cast_player_info
          ;;
        loop|pause)
          cmd_"$command"
          cast_player_info
          ;;
        next|previous)
          # no need to case in these cases since there is a cast_player_info
          # call in in play_song, this is needed to start casting before any
          # commands are read
          cmd_"$command"
          ;;
      esac
    done < "$cmds_fifo"
  done
}

cast_player_info() {
  if [ -n "$cast_player_info_pid" ]; then
    kill "$cast_player_info_pid"
  fi
  {
    if "$paused"; then
      status=Paused
    else
      status=Playing
    fi
    printf '%s: %s
Loop: %s
' "$status" "$song_basename" "$loop" > "$player_info_fifo"
    echo cast_player_info_end > "$cmds_fifo"
  } &
  cast_player_info_pid="$!"
}

play_song() {
  previous_song="$current_song" # only tracks "real" previously played song
  current_song="$1"
  song_basename="${current_song##*/}"
  song_basename="${song_basename%.*}"
  # fifo for blocking readers
  cast_player_info
  # And for potential non blocking readers
  printf '%s\n' "$song_basename" > "$song_playing_file"
  {
    trap 'echo player_end > "$cmds_fifo"' EXIT
    # Do not quote the player variable to allow the user to pass arguments, for
    # instance `player='cvlc --play-and-exit' ./shell-player songs/*.mp3`
    $player "$current_song" > /dev/null 2>&1 < /dev/null
  } &
  player_pid="$!"
  read_commands
}

play_all() {
  played_once=false

  while true; do
    for song do
      while true; do
        play_song "$song"
        if [ "$loop" != one ]; then
          break
        fi
      done
    done
    if [ "$loop" != all ]; then
      break
    fi
  done
}

play_all "$@"
